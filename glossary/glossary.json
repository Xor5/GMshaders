{
    "functions": [{
        "key": "texture2D",
        "def": "texture2D(sampler2D, vec2, [float])",
        "syntax": "texture2D(texture, coordinates, [bias])",
        "arguments_min": 2,
        "arguments": [{
            "key": "texture",
            "desc": "ID of the texture to sample."
        },{
            "key": "coordinates",
            "desc": "x and y texture coordinates of the pixel to sample."
        },{
            "key": "bias",
            "desc": "Optional mipmap bias (added to the LOD)."
        }],
        "returns": "vec4, RGBA",
        "desc": "",
        "examples":[
          "texture2D(gm_BaseTexture, v_vTexcoord);",
          "//Using the uniform uni_diffuse and 1.0 as the bias (half resolution with mipmapping).\ntexture2D(uni_diffuse, v_vTexcoord, 1.0);"]
    },{
        "key": "vec3",
        "def": "vec3(r, [g, b])",
        "syntax": "vec4(r, [g, b])",
        "arguments_min": 1,
        "arguments": [{
            "key": "r",
            "desc": "The red component of a color vector"
        },{
            "key": "g",
            "desc": "The green component of a color vector"
        },{
            "key": "b",
            "desc": "The blue component of a color vector"
        }],
        "returns": "vec3 object",
        "desc": "`vec3()` will create a vec3 object containing three values. Its values can be accessed with `.r`, `.b`, `.rgb`, etc. This is useful for storing color values with an alpha channel, but can be used as a container for any kind of data. Arithmetic operations performed on a vec3 object will be applied to each component of the vec3 object. `vec3(1. - vec3(.4, .2, .3))` will create a vec3 object with .6 red, .8 green and .7 blue. `vec3()` does not demand all arguments be satisfied. `vec3(.8)` will create a vec3 object and fill each channel with .8. It is equivalent to doing `vec3(.8, .8, .8)`",
        "examples":[]
    }]
}
