{
    "Attributes": [{
        "key": "in_Position",
        "def": "in_Position",
        "syntax": "attribute vec3 in_Position;",
        "returns": "vec3, vertex position",
        "desc": "Vertex position in model space. Most GML draw_* functions (e.g. draw_sprite) build their vertex buffer in world space so that they don't need the world matrix. Keep this in mind when you're using your own vertex buffer!",
        "examples":["//Output the projection-space vertex position.\ngl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * vec4(in_Position,1.);"]
    },{
        "key": "in_TextureCoord",
        "def": "in_TextureCoord",
        "syntax": "attribute vec3 in_Position;",
        "returns": "vec2, texture coordinates",
        "desc": "Alternative: `in_Texcoord`.<br>The texture coordinates (or uvs) range from 0 to 1 across the texture page. That means that surfaces and sprites that are on their own texture page will have normalized uvs, which can be very useful. However for other sprites you can always pass in the sprite uvs (from `sprite_get_uvs`) and normalize them yourself.",
        "examples":["//Pass a varying 'v_vTexcoord' to the fragment shader.\nv_vTexcoord = in_Texcoord;"]
    },{
        "key": "in_Colour",
        "def": "in_Colour",
        "syntax": "attribute vec4 in_Colour;",
        "returns": "vec4, vertex color and alpha",
        "desc": "Alternative: `in_Color`.<br>Vertex color and alpha. When applied to sprite this will be the image_blend and image_alpha, for most draw_* functions it will be the `draw_set_color` and `draw_set_alpha` and for vertex buffers/primitives, the color you set for each vertex. So 'in_Colour' can be useful in many situations!",
        "examples":["//Pass a varying 'v_vColour' to the fragment shader.\nv_vColour = in_Colour;"]
    }],
    "Functions": [{
        "key": "texture2D",
        "def": "texture2D(sampler2D, vec2, [float])",
        "syntax": "texture2D(texture, coordinates, [bias])",
        "arguments_min": 2,
        "arguments": [{
            "key": "texture",
            "desc": "ID of the texture to sample."
        },{
            "key": "coordinates",
            "desc": "x and y texture coordinates of the pixel to sample."
        },{
            "key": "bias",
            "desc": "Optional mipmap bias."
        }],
        "returns": "vec4, texel color and alpha",
        "desc": "Samples a texture at the given texture coordinates for color and alpha. Texture coordinates are between 0 to 1 and they represent a pixel on the sampler's texture page. Each texture has it's own texture coordinates so you may need to convert from once coordinate range to another by using `sprite_get_uvs` on both sprites. Surfaces and sprites with the 'Separate Texture Page' box ticked will always have a range of 0 to 1 so they are easier to deal with.<br>It's worth noting that the sampled pixel will be filtered by GM (no interpolation, linear interpolation or mipmapping, etc) which is why we call this a 'texel'.<br>With mipmapping you can add a bias to the current LOD level. But this does not work with surfaces!",
        "examples":[
          "texture2D(gm_BaseTexture, v_vTexcoord);",
          "//Using the sampler 'uni_diffuse' and 1.0 bias (half resolution with mipmapping).\ntexture2D(uni_diffuse, v_vTexcoord, 1.0);"]
    },{
        "key": "mix",
        "def": "mix(float/vec, float/vec, float/vec)",
        "syntax": "mix(x, y, a)",
        "arguments_min": 3,
        "arguments": [{
            "key": "x",
            "desc": "The first (or source) value."
        },{
            "key": "y",
            "desc": "The second (or destination) value."
        },{
            "key": "a",
            "desc": "The amount to intepolate."
        }],
        "returns": "float/vec mixture of a and b",
        "desc": "'Mix' is just like `lerp` in GML, but with it works with vectors as well. In case you're unfamiliar, it linearly interpolates between 'x' and 'y' by the amount 'a' so if `a = 0.0` then `mix(x,y,a) = x` and if `a = 1.0` then `mix(x,y,a) = y`. When a is anything between 0 and 1, the result will be somewhere between x and y.<br>Mix is calculated internally like so: `mix(x,y,a) = x*(1.-a) + y*a`<br>For this reason, 'x' and 'y' must have the same number of components. 'a' must as well unless it is a float.",
        "examples":[
          "//Mix between the source color and destination color, by 'factor' (float or vec3)\nvec3 col = mix(src,dst,factor);",
          "//Get the source's red and green channels and the destination's blue.\nvec3 col = mix(src,dst,vec3(0,0,1));"]
    }]
}
